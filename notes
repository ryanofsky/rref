-----------------------------------------------------------
template type deduction

  unify (pt.c, static)
    type_unification_real (pt.c, static)
      fn_type_unification (pt.c)
        add_template_candidate_real (call.c, static)
          add_template_candidate (call.c, static)
            convert_class_to_reference (call.c, static)*
            build_user_type_conversion_1 (call.c, static)*
            build_object_call (call.c, static)*
            add_candidates (call.c, static)*
            build_new_method.call (call.c, static)*
          add_template_conv_candidate (call.c, static)
            build_object_call (call.c, static)*
        resolve_address_of_overloaded_function (class.c, static)*
          instantiate_type (class.c)*
    try_one_overload (pt.c, static)
      resolve_overloaded_unification (pt.c, static)
        type_unification_real ...
    try_class_unification (pt.c, static)*
    get_class_bindings (pt.c, static)*

fn_type_unification
  (fn,
   explicit_targs,
   targs - deduced args out,
   args - function call args)

type_unification_real
  (tparms - DECL_INNERMOST_TEMPLATE_PARMS,
   targs - deduced args out,
   xparms - function declaration args,
   xargs - function call args)

   parm/parms, arg/args - iterated xparms, xargs

unify
  (tparms - template parameters
   targs - deduced args out
   parm - function declaration param type
   arg - funcion call arg type)

-----------------------------------------------------------
templates

TEMPLATE_DECL
  DECL_ARGUMENTS - param vector
  DECL_TEMPLATE_INFO - ?
  DECL_VINDEX - instantiation list
  DECL_INITIAL - for classes ?
  DECL_TEMPLATE_RESULT - for functions, FUNCTION_DECL with substituted params
  TREE_TYPE - for functions ?

TEMPLATE_PARM_INDEX
TEMPLATE_PARM_LEVEL
  numeric indices into param lists

// template parameters
TEMPLATE_TEMPLATE_PARM
  TYPE_FIELDS a is TEMPLATE_PARM_INDEX
TEMPLATE_TYPE_PARAM
  type parm, type.value field is a TEMPLATE_PARM_INDEX

TYPENAME_TYPE
  for "typename T::t"
  TYPE_CONTEXT is "T"
  TYPE_NAME is IDENTIFIER_NODE for "t"
TYPEOF_TYPE_PARM
  for typeof expressions

BOUND_TEMPLATE_TEMPLATE_PARAM
  for "TT<int>"
  TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO holds name & args
  TYPE_NAME is a TYPE_DECL

UNBOUND_CLASS_TEMPLATE
  for "T::template C"
  TYPE_CONTEXT is "T"
  TYPE_NAME is "IDENTIFIER_NODE" for "C"

TEMPLATE_ID_EXPR
  for "foo<int>"
  first operand is template
  second operand is NULL for no explicit arguments or a TREE_VEC of arguments

TINST_LEVEL
  node pointing to template declaration and location of instantiation, kept
  in a global stack

Members
  CLASSTYPE_TEMPLATE_INFO - template info from classtype
  DECL_TI_TEMPLATE(node) - TEMPLATE_DECL of instaniated/specialized NODE
  DECL_TI_ARGS(node) - full set of args passed to above to get NODE

-----------------------------------------------------------
reference collapsing

8.3.2/1 dcl.ref (158)
  cv-qualified references
8.3.2/4 dcl.ref (159)
  no refereces to references

reference to references
7.1.3/6 new para allowing for typedefs
14.3.1/4 new para allowing for template parameters
14.8.2/2 changed para allowing in template deduction

-----------------------------------------------------------
lvalue/rvalue stuff

3.10 basic.lval (81-82)
4/3 conv (83) result of implicit conversion
4.2 conv.lval (83) lvalue to rvalue conversion
8.5 dcl.init (167)
8.5.3 reference initialization
12.2 temporaries
12.8 direct initizliation

8.3.3/3 A pointer to member shall not point to ... a member with
reference type.

  lvalue_p_1 (static, tree.c)
    real_lvalue_p (tree.c)
      build_conditional_expr (call.c)
      make_temporary_var_for_ref_to_temp (call.c)
      convert_to_reference (cvt.c)
      convert_member_func_to_ptr (typeck.c)
    lvalue_p (tree.c)
      standard_conversion (call.c)
      convert_to_reference (cvt.c)
      build_array_ref (typeck.c)
      build_unary_op (typeck.c)
      convert_for_assignment (typeck.c)
      default_function_array_conversion (typeck.c)

-----------------------------------------------------------
overload resolution stuff

  finish_call_expr (semantics.c)
    build_new_method_call
    build_new_function_call
    build_new_op

  build_new_function_call (call.c)
    perform_overload_resolution (static)
      add_candidates (static)
        add_function_candidate (static)
          implicit_conversion (static)
            reference_binding (static)
            standard_conversion
            build_user_type_conversion_1
          add_candidate
        add_template_candidate (static)
          add_template_candidate_real (static)
            fn_type_unification
            instantiate_template
      splice_viable (static)
      tourney (static)
        joust (static)
          compare_ics
            maybe_handle_implicit_object
            maybe_handle_ref_bind
            is_subseq
            comp_cv_qual_signature
            comp_cv_qualification

-----------------------------------------------------------
reference binding stuff

reference_binding (call.c, static) called by
  implicit_conversion (call.c, static)
    reference_binding...
    add_function_candidate (call.c, static)*
    add_conv_candidate (call.c, static)*
    build_builtin_candidate (call.c, static)*
    build_user_type_conversion_1 (call.c, static)
      implicit_conversion...
      build_user_type_conversion (call.c)*
        convert_like_real (call.c, static)
          convert_like_real...
          perform_direct_initialization_if_possible (call.c)*
          initialize_reference (call.c)*
    conditional_conversion (call.c, static)*
    can_convert_arg (call.c)*
    can_convert_arg_bad (call.c)*
    perform_implicit_conversion (call.c)*
    perform_direct_initialization_if_possible (call.c)*
    conditional_expression (call.c)*
  initialize_reference (call.c)
    grok_reference_init (decl.c, static)
      check_initializer (decl.c, static)
        cp_finish_decl (decl.c)*
    convert_for_initialization (typeck.c)*

-----------------------------------------------------------
parsing stuff

simple-declaration:
  decl-specifier-seq[opt] init-declarator-list[opt]

  specifiers - type name, keyword modifiers
  declarators - names of things being declared, prefixed by
    optional *& and cv's

  ansi153 for declators

cp_parser_ptr_operator
  the ONLY place in the parse that takes CPP_AND for a reference decl.
  parses * & and following cv qualifiers.

  called in the following contexts

  cp_parser_new_type_id
    [follows "new" keyword and placement shits]
    cp_parser_type_specifier_seq
    cp_parser_new_declarator_opt
      **cp_parser_ptr_operator**

  cp_parser_conversion_type_id
    [follows "operator" keyword for user-defined conversion declarations]
    cp_parser_type_specifier_seq
    cp_parser_conversion_declarator_opt
      **cp_parser_ptr_operator**
    grokdeclarator

  cp_parser_declarator
    [gets types]
    **cp_parser_ptr_operator**
    cp_parser_direct_declarator

cp_parser_parameter_declaration
  parses parameter lists in function declarations

grokdeclarator (decl.c)
  enormous function that seems to be responsible for
  turning declarators into normal tree nodes

parser.c line 11322

